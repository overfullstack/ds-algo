package educative.elegant.unionfind

/* 11 Sep 2024 21:56 */

fun nodeToRemoveToMinimizeMalwareSpread(
  adjMatrix: Array<IntArray>,
  initiallyInfected: Set<Int>,
): Int {
  val unionFind = UnionFind4(adjMatrix)
  val rootToGroupCount = initiallyInfected.groupingBy(unionFind::find).eachCount()
  // * `1` because we need to find a large group where there is only 1 infected node.
  // * as we are allowed to remove only 1 node from group.
  // * So we ignore the group which has more than 1 infected node
  val candidates = initiallyInfected.filter { rootToGroupCount[unionFind.find(it)] == 1 }
  val maxRank = candidates.maxOfOrNull(unionFind::rootRank)
  return candidates.filter { unionFind.rootRank(it) == maxRank }.minOrNull()
    ?: initiallyInfected.minOrNull()!!
}

private class UnionFind4(adjMatrix: Array<IntArray>) {
  val roots = IntArray(adjMatrix.size) { it }
  val ranks = IntArray(adjMatrix.size)

  init {
    adjMatrix.indices
      .asSequence()
      .flatMap { row -> adjMatrix[0].indices.map { col -> row to col } }
      .filter { (row, col) -> adjMatrix[row][col] == 1 }
      .forEach { (row, col) -> union(row, col) }
  }

  tailrec fun find(n: Int): Int =
    when {
      roots[n] == n -> n
      else -> find(roots[n])
    }

  fun union(n1: Int, n2: Int) {
    val root1 = find(n1)
    val root2 = find(n2)
    if (root1 != root2) {
      when {
        ranks[root1] < ranks[root2] -> roots[root1] = root2
        ranks[root1] > ranks[root2] -> roots[root2] = root1
        else -> {
          roots[root1] = root2
          ranks[root2]++
        }
      }
    }
  }

  fun rootRank(n: Int): Int = ranks[find(n)]
}
