package educative.elegant.unionfind

/* 11 Sep 2024 21:56 */

fun nodeToRemoveToMinimizeMalwareSpread(
  adjMatrix: Array<IntArray>,
  initiallyInfected: Set<Int>,
): Int {
  val unionFind = UnionFind4(adjMatrix)
  // ! Infected root count - Indicates how many infected nodes are in a group
  val rootToInfectedNodeCountPerGroup = initiallyInfected.groupingBy(unionFind::find).eachCount()
  // ! Filter nodes that are the only infected node in that group
  val candidates =
    initiallyInfected.filter { rootToInfectedNodeCountPerGroup[unionFind.find(it)] == 1 }
  return candidates.maxOfOrNull(unionFind::rootRank)?.let { maxGroupSize ->
    candidates.filter { unionFind.rootRank(it) == maxGroupSize }.minOrNull()
  } ?: initiallyInfected.minOrNull()!!
}

private class UnionFind4(adjMatrix: Array<IntArray>) {
  val roots = IntArray(adjMatrix.size) { it }
  val ranks = IntArray(adjMatrix.size)

  init {
    adjMatrix.indices
      .asSequence()
      .flatMap { row -> adjMatrix[0].indices.map { col -> row to col } }
      .filter { (row, col) -> adjMatrix[row][col] == 1 }
      .forEach { (row, col) -> union(row, col) }
  }

  tailrec fun find(n: Int): Int =
    when {
      roots[n] == n -> n
      else -> find(roots[n])
    }

  fun union(n1: Int, n2: Int) {
    val root1 = find(n1)
    val root2 = find(n2)
    if (root1 != root2) {
      when {
        ranks[root1] < ranks[root2] -> roots[root1] = root2
        ranks[root1] > ranks[root2] -> roots[root2] = root1
        else -> {
          roots[root1] = root2
          ranks[root2]++
        }
      }
    }
  }

  fun rootRank(n: Int): Int = ranks[find(n)]
}
